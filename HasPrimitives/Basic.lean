import Mathlib.Analysis.Complex.CauchyIntegral

/-%%
This project aims to formalize a proof that holomorphic functions on discs have primitives.
%%-/

open Complex Topology Set Metric

set_option autoImplicit true

open scoped Interval

namespace Asymptotics

/-- `f : Œ± ‚Üí E` is `ContinuousAt` `x` iff the map `y ‚Ü¶ f y - f x` is littleO of 1 as `y ‚Üí x`. -/
theorem continuousAt_iff_isLittleO {Œ± : Type*} {E : Type*} [NormedRing E] [NormOneClass E]
    [TopologicalSpace Œ±] {f : Œ± ‚Üí E} {x : Œ±} :
    (ContinuousAt f x) ‚Üî (fun (y : Œ±) ‚Ü¶ f y - f x) =o[ùìù x] (fun (_ : Œ±) ‚Ü¶ (1 : E)) := by
  convert (Asymptotics.isLittleO_one_iff (f' := fun (y : Œ±) => f y - f x) (l := ùìù x) (F := E)).symm
  exact Iff.symm tendsto_sub_nhds_zero_iff

end Asymptotics

namespace Set

-- TO DO: move to `Mathlib.Data.Intervals.UnorderedInterval` (Yael add API?)
def uIoo {Œ± : Type*} [LinearOrder Œ±]  : Œ± ‚Üí Œ± ‚Üí Set Œ± := fun a b => Ioo (a ‚äì b) (a ‚äî b)

-- TO DO: move to `Mathlib.Data.Intervals.UnorderedInterval` (Yael add API?)
theorem uIoo_comm {Œ± : Type*} [LinearOrder Œ±] (a : Œ±) (b : Œ±) :
    uIoo a b = uIoo b a := by simp [uIoo, inf_comm, sup_comm]

theorem uIoo_subset_uIcc {Œ± : Type*} [LinearOrder Œ±] (a : Œ±) (b : Œ±) :
    uIoo a b ‚äÜ uIcc a b := by simp [uIoo, uIcc, Ioo_subset_Icc_self]

end Set

namespace Complex

/-- This lemma shows the equality between the convext hull of a complex product set and
  the complex product of convex hulls. -/
lemma convexHull_reProdIm (s t : Set ‚Ñù) :
    convexHull ‚Ñù (s √ó‚ÑÇ t) = convexHull ‚Ñù s √ó‚ÑÇ convexHull ‚Ñù t :=
  calc
    convexHull ‚Ñù (equivRealProdLm ‚Åª¬π' (s √óÀ¢ t)) = equivRealProdLm ‚Åª¬π' (convexHull ‚Ñù (s √óÀ¢ t)) := by
      simpa only [‚Üê LinearEquiv.image_symm_eq_preimage]
        using equivRealProdLm.symm.toLinearMap.convexHull_image (s √óÀ¢ t)
    _ = convexHull ‚Ñù s √ó‚ÑÇ convexHull ‚Ñù t := by rw [convexHull_prod]; rfl

/-- The preimage under `equivRealProd` of `s √óÀ¢ t` is `s √ó‚ÑÇ t`. -/
lemma preimage_equivRealProd_prod (s t : Set ‚Ñù) : equivRealProd ‚Åª¬π' (s √óÀ¢ t) = s √ó‚ÑÇ t := rfl

/-- The inequality `s √ó t ‚äÜ s‚ÇÅ √ó t‚ÇÅ` holds in `‚ÑÇ` iff it holds in `‚Ñù √ó ‚Ñù`. -/
theorem reProdIm_subset_iff {s s‚ÇÅ t t‚ÇÅ : Set ‚Ñù} : s √ó‚ÑÇ t ‚äÜ s‚ÇÅ √ó‚ÑÇ t‚ÇÅ ‚Üî s √óÀ¢ t ‚äÜ s‚ÇÅ √óÀ¢ t‚ÇÅ := by
  rw [‚Üê @preimage_equivRealProd_prod s t, ‚Üê @preimage_equivRealProd_prod s‚ÇÅ t‚ÇÅ]
  exact Equiv.preimage_subset equivRealProd _ _

/-- If `s ‚äÜ s‚ÇÅ ‚äÜ ‚Ñù` and `t ‚äÜ t‚ÇÅ ‚äÜ ‚Ñù`, then `s √ó t ‚äÜ s‚ÇÅ √ó t‚ÇÅ` in `‚ÑÇ`. -/
theorem reProdIm_subset_iff' {s s‚ÇÅ t t‚ÇÅ : Set ‚Ñù} :
    s √ó‚ÑÇ t ‚äÜ s‚ÇÅ √ó‚ÑÇ t‚ÇÅ ‚Üî s ‚äÜ s‚ÇÅ ‚àß t ‚äÜ t‚ÇÅ ‚à® s = ‚àÖ ‚à® t = ‚àÖ := by
  convert prod_subset_prod_iff
  exact reProdIm_subset_iff

/-- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product
  of two intervals, which is also the convex hull of the four corners. -/
lemma segment_reProdIm_segment_eq_convexHull (z w : ‚ÑÇ) :
    [[z.re, w.re]] √ó‚ÑÇ [[z.im, w.im]] = convexHull ‚Ñù {z, z.re + w.im * I, w.re + z.im * I, w} := by
  simp_rw [‚Üê segment_eq_uIcc, ‚Üê convexHull_pair, ‚Üê convexHull_reProdIm,
    ‚Üê preimage_equivRealProd_prod, insert_prod, singleton_prod, image_pair,
    insert_union, ‚Üê insert_eq, preimage_equiv_eq_image_symm, image_insert_eq, image_singleton,
    equivRealProd_symm_apply, re_add_im]

/-%%
\begin{definition}[Rectangle]
  \label{Rectangle}
  \lean{Rectangle}\leanok
    Given points $z$ and $w$ in $\mathbb C$, a ``Rectangle'' means an axis-parallel rectangle with
    corners $z$ and $w$.
\end{definition}
%%-/
/-- A `Rectangle` is an axis-parallel rectangle with corners `z` and `w`. -/
def Rectangle (z w : ‚ÑÇ) : Set ‚ÑÇ := [[z.re, w.re]] √ó‚ÑÇ [[z.im, w.im]]

/-- If the four corners of a rectangle are contained in a convex set `U`, then the whole
  rectangle is. -/
theorem rectangle_in_convex {U : Set ‚ÑÇ} (U_convex : Convex ‚Ñù U) {z w : ‚ÑÇ} (hz : z ‚àà U)
    (hw : w ‚àà U) (hzw : (z.re + w.im * I) ‚àà U) (hwz : (w.re + z.im * I) ‚àà U) :
    Rectangle z w ‚äÜ U := by
  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]
  convert convexHull_min ?_ (U_convex)
  refine insert_subset hz (insert_subset hzw (insert_subset hwz ?_))
  exact singleton_subset_iff.mpr hw

/-- If `z` is in a ball centered at `c`, then `z.re + c.im * I` is in the ball. -/
lemma cornerRectangle_in_disc {c : ‚ÑÇ} {r : ‚Ñù} {z : ‚ÑÇ} (hz : z ‚àà ball c r) :
    z.re + c.im * I ‚àà ball c r := by
  simp only [mem_ball] at hz ‚ä¢
  rw [dist_of_im_eq] <;> simp only [add_re, I_re, mul_zero, I_im, zero_add, add_im,
    add_zero, sub_self, mul_re, mul_one, ofReal_im, mul_im, ofReal_re]
  apply lt_of_le_of_lt ?_ hz
  rw [dist_eq_re_im, Real.dist_eq]
  apply Real.le_sqrt_of_sq_le
  simp only [_root_.sq_abs, le_add_iff_nonneg_right, ge_iff_le, sub_nonneg]
  exact sq_nonneg _

/-- As `w ‚Üí z`, `w.re - z.re` is big-O of `w - z`. -/
theorem re_isBigO {z : ‚ÑÇ} :
  (fun (w : ‚ÑÇ) => w.re - z.re) =O[ùìù z] fun w => w - z := by
  rw [Asymptotics.isBigO_iff]
  use 1
  filter_upwards
  intro w
  simp only [Real.norm_eq_abs, Complex.norm_eq_abs, one_mul]
  rw [‚Üê Complex.sub_re]
  exact Complex.abs_re_le_abs (w - z)

/-- As `w ‚Üí z`, `w.im - z.im` is big-O of `w - z`. -/
theorem im_isBigO {z : ‚ÑÇ} :
  (fun (w : ‚ÑÇ) => w.im - z.im) =O[ùìù z] fun w => w - z := by
  rw [Asymptotics.isBigO_iff]
  use 1
  filter_upwards
  intro w
  simp only [Real.norm_eq_abs, Complex.norm_eq_abs, one_mul]
  rw [‚Üê Complex.sub_im]
  exact Complex.abs_im_le_abs (w - z)

/-- A real segment `[a‚ÇÅ, a‚ÇÇ]` translated by `b * I` is the complex line segment. -/
theorem horizontalSegment_eq (a‚ÇÅ a‚ÇÇ b : ‚Ñù) :
    (fun x => ‚Üëx + ‚Üëb * I) '' [[a‚ÇÅ, a‚ÇÇ]] = [[a‚ÇÅ, a‚ÇÇ]] √ó‚ÑÇ {b} := by
  rw [‚Üê preimage_equivRealProd_prod]
  ext x
  constructor
  ¬∑ intro hx
    obtain ‚ü®x‚ÇÅ, hx‚ÇÅ, hx‚ÇÅ'‚ü© := hx
    simp [‚Üê hx‚ÇÅ', mem_preimage, mem_prod, hx‚ÇÅ]
  ¬∑ intro hx
    obtain ‚ü®x‚ÇÅ, hx‚ÇÅ, hx‚ÇÅ', hx‚ÇÅ''‚ü© := hx
    refine ‚ü®x.re, x‚ÇÅ, by simp‚ü©

/-- A vertical segment `[b‚ÇÅ, b‚ÇÇ]` translated by `a` is the complex line segment. -/
theorem verticalSegment_eq (a b‚ÇÅ b‚ÇÇ : ‚Ñù) :
    (fun y => ‚Üëa + ‚Üëy * I) '' [[b‚ÇÅ, b‚ÇÇ]] = {a} √ó‚ÑÇ [[b‚ÇÅ, b‚ÇÇ]] := by
  rw [‚Üê preimage_equivRealProd_prod]
  ext x
  constructor
  ¬∑ intro hx
    obtain ‚ü®x‚ÇÅ, hx‚ÇÅ, hx‚ÇÅ'‚ü© := hx
    simp [‚Üê hx‚ÇÅ', mem_preimage, mem_prod, hx‚ÇÅ]
  ¬∑ intro hx
    simp only [equivRealProd_apply, singleton_prod, mem_image, Prod.mk.injEq,
      exists_eq_right_right, mem_preimage] at hx
    obtain ‚ü®x‚ÇÅ, hx‚ÇÅ, hx‚ÇÅ', hx‚ÇÅ''‚ü© := hx
    refine ‚ü®x.im, x‚ÇÅ, by simp‚ü©

end Complex

namespace Metric

/-- If `z` is in a ball centered at `c` with radius `r`, then the ball centered at `z` with radius
  `r - dist z c` is contained in the original ball. -/
theorem ball_subset_ball‚ÇÅ {c : ‚ÑÇ} {r : ‚Ñù} {z : ‚ÑÇ} (hz : z ‚àà ball c r) :
    ball z (r - dist z c) ‚äÜ ball c r := by
  intro w hw
  simp only [mem_ball] at hw hz ‚ä¢
  nlinarith [dist_triangle w z c]

end Metric

section SubsetBall_Aux

/- Auxiliary lemmata about subsets of balls -/

theorem mem_ball_re_aux {c : ‚ÑÇ} {r : ‚Ñù} {z : ‚ÑÇ} :
    (Ioo (z.re - (r - dist z c)) (z.re + (r - dist z c))) √ó‚ÑÇ {z.im} ‚äÜ ball z (r - dist z c) := by
  intro x hx
  obtain ‚ü®xRe, xIm‚ü© := hx
  simp only [mem_preimage, mem_singleton_iff, mem_Ioo] at xRe xIm
  simp only [mem_ball]
  rw [dist_eq_re_im, xIm]
  simp only [sub_self, ne_eq, not_false_eq_true, zero_pow', add_zero, Real.sqrt_sq_eq_abs, abs_lt]
  refine ‚ü®by linarith, by linarith‚ü©

theorem mem_ball_re_aux' {c : ‚ÑÇ} {r : ‚Ñù} {z : ‚ÑÇ} (hz : z ‚àà ball c r) {x : ‚Ñù}
    (hx : x ‚àà Ioo (z.re - (r - dist z c)) (z.re + (r - dist z c))) :
    x + z.im * I ‚àà ball c r := by
  set r‚ÇÅ := r - dist z c
  set s := Ioo (z.re - r‚ÇÅ) (z.re + r‚ÇÅ)
  have s_ball‚ÇÅ : s √ó‚ÑÇ {z.im} ‚äÜ ball z r‚ÇÅ := mem_ball_re_aux
  have s_ball : s √ó‚ÑÇ {z.im} ‚äÜ ball c r := Subset.trans s_ball‚ÇÅ (ball_subset_ball‚ÇÅ hz)
  apply s_ball
  rw [mem_reProdIm]
  simp only [add_re, ofReal_re, mul_re, I_re, mul_zero, ofReal_im, I_im, mul_one, sub_self,
    add_zero, gt_iff_lt, not_lt, ge_iff_le, mem_Ioo, add_im, mul_im, zero_add, mem_singleton_iff,
    and_true]
  apply hx

theorem mem_closedBall_aux {c : ‚ÑÇ} {r : ‚Ñù} {z : ‚ÑÇ} (z_in_ball : z ‚àà closedBall c r)
    {y : ‚Ñù} (y_in_I : y ‚àà Œô c.im z.im) : z.re + y * I ‚àà closedBall c r := by
  rw [mem_closedBall] at z_in_ball ‚ä¢
  rw [mem_uIoc] at y_in_I
  apply le_trans ?_ z_in_ball
  rw [dist_eq_re_im, dist_eq_re_im]
  apply Real.le_sqrt_of_sq_le
  rw [Real.sq_sqrt (by positivity)]
  simp only [add_re, ofReal_re, mul_re, I_re, mul_zero, ofReal_im, I_im, mul_one, sub_self,
    add_zero, add_im, mul_im, zero_add, add_le_add_iff_left]
  cases y_in_I <;> nlinarith

theorem mem_ball_of_map_re_aux {c : ‚ÑÇ} {r : ‚Ñù} {a‚ÇÅ a‚ÇÇ b : ‚Ñù} (ha‚ÇÅ : a‚ÇÅ + b * I ‚àà ball c r)
    (ha‚ÇÇ : a‚ÇÇ + b * I ‚àà ball c r) : (fun (x : ‚Ñù) => x + b * I) '' [[a‚ÇÅ, a‚ÇÇ]] ‚äÜ ball c r := by
  convert rectangle_in_convex (convex_ball c r) ha‚ÇÅ ha‚ÇÇ ?_ ?_ using 1 <;>
    simp only [add_re, ofReal_re, mul_re, I_re, mul_zero, ofReal_im, I_im, mul_one, sub_self,
      add_zero, add_im, mul_im, zero_add, ha‚ÇÅ, ha‚ÇÇ, Rectangle]
  simp [horizontalSegment_eq a‚ÇÅ a‚ÇÇ b]

theorem mem_ball_of_map_im_aux {c : ‚ÑÇ} {r : ‚Ñù} {a b‚ÇÅ b‚ÇÇ : ‚Ñù} (hb‚ÇÅ : a + b‚ÇÅ * I ‚àà ball c r)
    (hb‚ÇÇ : a + b‚ÇÇ * I ‚àà ball c r) : (fun (y : ‚Ñù) => a + y * I) '' [[b‚ÇÅ, b‚ÇÇ]] ‚äÜ ball c r := by
  convert rectangle_in_convex (convex_ball c r) hb‚ÇÅ hb‚ÇÇ ?_ ?_ using 1 <;>
  simp only [add_re, ofReal_re, mul_re, I_re, mul_zero, ofReal_im, I_im, mul_one, sub_self,
    add_zero, add_im, mul_im, zero_add, hb‚ÇÅ, hb‚ÇÇ, Rectangle]
  simp [verticalSegment_eq a b‚ÇÅ b‚ÇÇ]
-- NOTE: I don't know why these `simp`s can't be combined.

end SubsetBall_Aux

section ContinuousOn_Aux
/- Auxiliary lemmata about continuity of various occurring functions -/

theorem ContinuousOn.im_aux_1 {c : ‚ÑÇ} {r : ‚Ñù} {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : ContinuousOn f (ball c r)) {z : ‚ÑÇ}
    (hz : z ‚àà ball c r) (w : ‚ÑÇ) : ContinuousOn (fun (y : ‚Ñù) => f (w.re + y * I)) [[z.im, w.im]] := by
  sorry

theorem ContinuousOn.re_aux_1 {c : ‚ÑÇ} {r : ‚Ñù} {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : ContinuousOn f (ball c r)) {z : ‚ÑÇ}
    (hz : z ‚àà ball c r) : ContinuousOn (fun (x : ‚Ñù) => f (x + z.im * I))
                            (Ioo (z.re - (r - dist z c)) (z.re + (r - dist z c))) := by
  apply (hf.comp ((continuous_add_right _).comp continuous_ofReal).continuousOn)
  intro x hx
  change x + z.im * I ‚àà ball c r
  exact mem_ball_re_aux' hz hx

theorem ContinuousOn.re_aux_2 {c : ‚ÑÇ} {r : ‚Ñù} {f : ‚ÑÇ ‚Üí ‚ÑÇ}
    (f_cont : ContinuousOn f (ball c r)) {a‚ÇÅ a‚ÇÇ b : ‚Ñù} (ha‚ÇÅ : a‚ÇÅ + b * I ‚àà ball c r)
    (ha‚ÇÇ : a‚ÇÇ + b * I ‚àà ball c r) : ContinuousOn (fun x => f (‚Üëx + ‚Üëb * I)) [[a‚ÇÅ, a‚ÇÇ]] := by
  convert ContinuousOn.comp (g := f) (f := fun (x : ‚Ñù) => (x : ‚ÑÇ) + b * I) (s := uIcc a‚ÇÅ a‚ÇÇ)
    (t := (fun (x : ‚Ñù) => (x : ‚ÑÇ) + b * I) '' (uIcc a‚ÇÅ a‚ÇÇ)) ?_ ?_ (mapsTo_image _ _)
  ¬∑ apply f_cont.mono (mem_ball_of_map_re_aux ha‚ÇÅ ha‚ÇÇ)
  ¬∑ exact Continuous.continuousOn (Continuous.comp (continuous_add_right _) continuous_ofReal)

theorem ContinuousOn.im_aux {c : ‚ÑÇ} {r : ‚Ñù} {f : ‚ÑÇ ‚Üí ‚ÑÇ}
    (f_cont : ContinuousOn f (ball c r)) {a b‚ÇÅ b‚ÇÇ : ‚Ñù} (hb‚ÇÅ : a + b‚ÇÅ * I ‚àà ball c r) (hb‚ÇÇ : a + b‚ÇÇ * I ‚àà ball c r) :
    ContinuousOn (fun (y : ‚Ñù) => f (a + y * I)) [[b‚ÇÅ, b‚ÇÇ]] := by
  convert ContinuousOn.comp (g := f) (f := fun (y : ‚Ñù) => (a : ‚ÑÇ) + y * I) (s := uIcc b‚ÇÅ b‚ÇÇ)
    (t := (fun (y : ‚Ñù) => (a : ‚ÑÇ) + y * I) '' (uIcc b‚ÇÅ b‚ÇÇ)) ?_ ?_ (mapsTo_image _ _)
  ¬∑ apply f_cont.mono (mem_ball_of_map_im_aux hb‚ÇÅ hb‚ÇÇ)
  ¬∑ apply Continuous.continuousOn
    exact ((continuous_add_left _).comp (continuous_mul_right _)).comp continuous_ofReal

end ContinuousOn_Aux






























namespace Complex

/-%%
\begin{definition}[Has Primitives]
  \label{HasPrimitives}
  \lean{HasPrimitives}\leanok
  Given a set $U\subset\mathbb C$, for any differentiable $f:U\to\mathbb C$, there exists a
  differentiable $g:U\to\mathbb C$ such that $g'=f$ on $U$.
\end{definition}
%%-/
/-- A set `U` `HasPrimitives` if, every holomorphic function on `U` has a primitive -/
def HasPrimitives (U : Set ‚ÑÇ) : Prop :=
  ‚àÄ f : ‚ÑÇ ‚Üí ‚ÑÇ, DifferentiableOn ‚ÑÇ f U ‚Üí ‚àÉ g : ‚ÑÇ ‚Üí ‚ÑÇ, ‚àÄ z ‚àà U, HasDerivAt g (f z) z

/-%%
A wedge is the union of a horizontal line and a vertical line.

\begin{definition}[Wedge Integral]
  \label{WedgeInt}
  \lean{WedgeInt}\leanok
  \uses{linint}
  Given $z,w\in\mathbb C$ and a function $f:\mathbb C\to\mathbb C$, the wedge integral from
  $z$ to $w$ is defined as the sum of two complex integrals, one along the horizontal path
  from $z$ to $\Re(w)+i \Im(z)$, and another along a vertical path from there to $w$,
   \begin{equation}
      \int_{z\to_W\  w} f(x)\ dx
      :=
      \int_{\Re(z)}^{\Re(w)} f(x+i\Im(z))\ dx
      +
      i\int_{\Im(z)}^{\Im(w)} f(\Re(w)+iy)\ dy
      .
   \end{equation}
\end{definition}
%%-/
/-- The wedge integral from `z` to `w` of a function `f` -/
noncomputable def WedgeInt (z w : ‚ÑÇ) (f : ‚ÑÇ ‚Üí ‚ÑÇ) : ‚ÑÇ :=
  (‚à´ x : ‚Ñù in z.re..w.re, f (x + z.im * I)) + I ‚Ä¢ (‚à´ y : ‚Ñù in z.im..w.im, f (re w + y * I))

/-%%
A ``Rectangle Integral'' is what it sounds like.

\begin{definition}[Rectangle Integral]
  \label{RectangleIntegral}
  \lean{RectangleIntegral}\leanok
  Given $z,w\in\mathbb C$ and a function $f:\mathbb C\to\mathbb C$, the rectangle integral is
  defined as the sum of four complex integrals:
   \begin{eqnarray}
      \int_{R(z,w)} f(x)\ dx
      &:=&
      \int_{\Re(z)}^{\Re(w)} f(x+i\Im(z))\ dx
      -
      \int_{\Re(z)}^{\Re(w)} f(x+i\Im(w))\ dx
      \\
      &&+
      i\int_{\Im(z)}^{\Im(w)} f(\Re(w)+iy)\ dy
      -
      i\int_{\Im(z)}^{\Im(w)} f(\Re(z)+iy)\ dy
      .
   \end{eqnarray}
\end{definition}
%%-/
/-- A `RectangleIntegral` of a function `f` is one over a rectangle determined by
  `z` and `w` in `‚ÑÇ`. -/
noncomputable def RectangleIntegral (f : ‚ÑÇ ‚Üí ‚ÑÇ) (z w : ‚ÑÇ) : ‚ÑÇ :=
    (‚à´ x : ‚Ñù in z.re..w.re, f (x + z.im * I)) - (‚à´ x : ‚Ñù in z.re..w.re, f (x + w.im * I))
     + I ‚Ä¢ (‚à´ y : ‚Ñù in z.im..w.im, f (w.re + y * I)) - I ‚Ä¢ ‚à´ y : ‚Ñù in z.im..w.im, f (z.re + y * I)

/-%%
We say that a function $f$ ``vanishes on rectangles in a disc'', $D(c,r)$ if, for any rectangle
contained in $D(c,r)$, the integral of $f$ over the rectangle is zero.
\begin{definition}[Vanishes On Rectangles In Disc]
  \label{VanishesOnRectanglesInDisc}
  \lean{VanishesOnRectanglesInDisc}\leanok
  A function $f:\mathbb C\to\mathbb C$ vanishes on rectangles in a disc $D(c,r)$ if, for any
  rectangle $R(z,w)$ contained in $D(c,r)$, the integral of $f$ over the rectangle is zero.
\end{definition}
%%-/
/-- A function `f` `VanishesOnRectanglesInDisc` if, for any rectangle contained in a disc,
  the integral of `f` over the rectangle is zero. -/
def VanishesOnRectanglesInDisc (c : ‚ÑÇ) (r : ‚Ñù) (f : ‚ÑÇ ‚Üí ‚ÑÇ) : Prop :=
    ‚àÄ z w, z ‚àà ball c r ‚Üí w ‚àà ball c r ‚Üí (z.re + w.im * I) ‚àà ball c r ‚Üí
    (w.re + z.im * I) ‚àà ball c r ‚Üí RectangleIntegral f z w = 0

/-%%
If a function $f$ vanishes on rectangles in a disc $D(c,r)$, then, for any $w$ in a neighborhood
of $z$ in $D(c,r)$, the wedge integral from $c$ to $w$ minus the wedge integral from $c$ to $z$
is equal to the wedge integral from $z$ to $w$.
\begin{lemma}[Wedge Integral Difference]
  \label{diff_of_wedges}
  \lean{VanishesOnRectanglesInDisc.diff_of_wedges}\leanok
  \uses{VanishesOnRectanglesInDisc}
  If a function $f$ vanishes on rectangles in a disc $D(c,r)$, then, for any $w$ in a
  neighborhood of $z$ in $D(c,r)$,
  $$
    \int_{c\to_W\  w} f(x)\ dx
    -
    \int_{c\to_W\  z} f(x)\ dx
    =
    \int_{z\to_W\  w} f(x)\ dx
    .
  $$
\end{lemma}
%%-/
/-- If a function `f` `VanishesOnRectanglesInDisc` of center `c`, then, for all `w` in a
  neighborhood of `z`, the wedge integral from `c` to `w` minus the wedge integral from `c` to `z`
  is equal to the wedge integral from `z` to `w`. -/
lemma VanishesOnRectanglesInDisc.diff_of_wedges {c : ‚ÑÇ} {r : ‚Ñù} {z : ‚ÑÇ}
    (hz : z ‚àà ball c r) {f : ‚ÑÇ ‚Üí ‚ÑÇ} (f_cont : ContinuousOn f (ball c r))
    (hf : VanishesOnRectanglesInDisc c r f) :
    ‚àÄ·∂† (w : ‚ÑÇ) in ùìù z,
      WedgeInt c w f - WedgeInt c z f = WedgeInt z w f := by
--%% \begin{proof}
  have hr : 0 < r := pos_of_mem_ball hz
--%% Set $r_1>0$ to be the distance from $z$ to the boundary of $D(c,r)$,
  let r‚ÇÅ := r - dist z c
  have r‚ÇÅ_pos : 0 < r‚ÇÅ := by simp only [mem_ball, gt_iff_lt] at hz ‚ä¢; linarith
--%% so that the disc $D(z,r_1)$ is contained in $D(c,r)$.
  have z_ball : ball z r‚ÇÅ ‚äÜ ball c r := ball_subset_ball‚ÇÅ hz
--%% Then for $w$ to be in a ``neighborhood of $z$'', it suffices to be in $D(z,r_1)$.
  filter_upwards [ball_mem_nhds z r‚ÇÅ_pos]
  intro w w_in_z_ball
  have hzPlusH : w ‚àà ball c r := mem_of_subset_of_mem z_ball w_in_z_ball
  simp only [WedgeInt]
--%% It is convenient to name some of the arising line integrals, to be used again and again.
--%% We define $I_1$ to be the integral along the horizontal path from $c$ to $\Re(w)+i\Im(c)$.
  set intI := ‚à´ x : ‚Ñù in c.re..(w).re, f (x + c.im * I)
--%% We define $I_2$ to be the integral along the vertical path from $\Re(w)+i\Im(c)$ to $w$.
  set intII := I ‚Ä¢ ‚à´ y : ‚Ñù in c.im..w.im, f (w.re + y * I)
--%% We define $I_3$ to be the integral along the horizontal path from $c$ to $\Re(z)+i\Im(c)$.
  set intIII := ‚à´ x : ‚Ñù in c.re..z.re, f (x + c.im * I)
--%% We define $I_4$ to be the integral along the vertical path from $\Re(z)+i\Im(c)$ to $z$.
  set intIV := I ‚Ä¢ ‚à´ y : ‚Ñù in c.im..z.im, f (z.re + y * I)
--%% We define $I_5$ to be the integral along the horizontal path from $z$ to $\Re(w)+i\Im(z)$.
  set intV := ‚à´ x : ‚Ñù in z.re..w.re, f (x + z.im * I)
--%% We define $I_6$ to be the integral along the vertical path from $\Re(w)+i\Im(z)$ to $w$.
  set intVI := I ‚Ä¢ ‚à´ y : ‚Ñù in z.im..w.im, f (w.re + y * I)
--%% We define $I_7$ to be the integral along the horizontal path from $\Re(z)+i\Im(c)$ to
--%% $\Re(w)+i\Im(c)$.
  let intVII := ‚à´ x : ‚Ñù in z.re..w.re, f (x + c.im * I)
--%% We define $I_8$ to be the integral along the vertical path from $\Re(w)+i\Im(c)$ to
--%% $\Re(w)+i\Im(z)$.
  let intVIII := I ‚Ä¢ ‚à´ y : ‚Ñù in c.im..z.im, f (w.re + y * I)
  have integrableHoriz : ‚àÄ a‚ÇÅ a‚ÇÇ b : ‚Ñù, a‚ÇÅ + b * I ‚àà ball c r ‚Üí a‚ÇÇ + b * I ‚àà ball c r
    ‚Üí IntervalIntegrable (fun x => f (x + b * I)) MeasureTheory.volume a‚ÇÅ a‚ÇÇ :=
      fun a‚ÇÅ a‚ÇÇ b ha‚ÇÅ ha‚ÇÇ ‚Ü¶
        ContinuousOn.intervalIntegrable (f_cont.re_aux_2 ha‚ÇÅ ha‚ÇÇ)
  have integrableVert : ‚àÄ a b‚ÇÅ b‚ÇÇ : ‚Ñù, a + b‚ÇÅ * I ‚àà ball c r ‚Üí a + b‚ÇÇ * I ‚àà ball c r
    ‚Üí IntervalIntegrable (fun y => f (a + y * I)) MeasureTheory.volume b‚ÇÅ b‚ÇÇ
  ¬∑ intro a b‚ÇÅ b‚ÇÇ hb‚ÇÅ hb‚ÇÇ
    apply ContinuousOn.intervalIntegrable (f_cont.im_aux hb‚ÇÅ hb‚ÇÇ)
--%% Then $I_1$ is equal to $I_3+I_7$,
  have intIdecomp : intI = intIII + intVII
  ¬∑ rw [intervalIntegral.integral_add_adjacent_intervals] <;> apply integrableHoriz
    ¬∑ simp only [re_add_im, mem_ball, dist_self, hr]
    ¬∑ exact cornerRectangle_in_disc hz
    ¬∑ exact cornerRectangle_in_disc hz
    ¬∑ exact cornerRectangle_in_disc hzPlusH
--%% and $I_2$ is equal to $I_6+I_8$.
  have intIIdecomp : intII = intVIII + intVI
  ¬∑ rw [‚Üê smul_add, intervalIntegral.integral_add_adjacent_intervals] <;> apply integrableVert
    ¬∑ exact cornerRectangle_in_disc hzPlusH
    ¬∑ apply mem_of_subset_of_mem z_ball (cornerRectangle_in_disc w_in_z_ball)
    ¬∑ apply mem_of_subset_of_mem z_ball (cornerRectangle_in_disc w_in_z_ball)
    ¬∑ convert hzPlusH using 1; ext <;> simp
  have rectZero : intVIII = - intVII + intV + intIV
  ¬∑ rw [‚Üê sub_eq_zero]
--%% Moreover, $I_7 - I_5 + I_8 - I_4$ forms a rectangle, and hence its integral is zero.
    have : intVII - intV + intVIII - intIV = 0 := by
      have wzInBall : w.re + z.im * I ‚àà ball c r :=
        by exact mem_of_subset_of_mem z_ball (cornerRectangle_in_disc w_in_z_ball)
      have wcInBall : w.re + c.im * I ‚àà ball c r := cornerRectangle_in_disc hzPlusH
      convert hf (z.re + c.im * I) (w.re + z.im * I) (cornerRectangle_in_disc hz) wzInBall
          (by simpa using hz) (by simpa using wcInBall) using 1
      rw [RectangleIntegral]
      congr <;> simp
    rw [‚Üê this]
    ring
  rw [intIdecomp, intIIdecomp, rectZero]
  ring
--%% Putting everything together shows that the wedge integral difference is equal to the wedge,
--%% as claimed.
--%% \end{proof}

/-%%
Next we claim that, as $x \to \Re(z)$, the horizontal integral of a continuous $f$
from $z$ to $x + i\Im(z)$ is equal to $(x - \Re(z)) f(z)$, up to $o(x - \Re(z))$.
\begin{lemma}
  \label{deriv_of_wedgeInt_re'}
  \lean{deriv_of_wedgeInt_re'}\leanok
  As $x \to \Re(z)$,
  $$
    \int_{\Re(z)}^x f(t + i\Im(z))\ dt
    =
    (x-\Re(z)) f(z)
    +
    o(x-\Re(z))
    .
  $$
\end{lemma}
%%-/
/-- The integral of a continuous function `f` from `z` to `x + z.im * I` is equal to
  `(x - z.re) * f z` up to `o(x - z.re)`. -/
theorem deriv_of_wedgeInt_re' {c : ‚ÑÇ} {r : ‚Ñù} {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : ContinuousOn f (ball c r))
  {z : ‚ÑÇ} (hz : z ‚àà ball c r) :
  (fun (x : ‚Ñù) ‚Ü¶ (‚à´ t in z.re..x, f (t + z.im * I)) - (x - z.re) * f z)
    =o[ùìù z.re] (fun (x : ‚Ñù)  ‚Ü¶ x - z.re) := by
--%% \begin{proof}
  let r‚ÇÅ := r - dist z c
  have : 0 < r‚ÇÅ := by simp only [mem_ball, gt_iff_lt] at hz ‚ä¢; linarith
  let s : Set ‚Ñù := Ioo (z.re - r‚ÇÅ) (z.re + r‚ÇÅ)
  have zRe_mem_s : z.re ‚àà s := by simp [mem_ball.mp hz]
  have s_open : IsOpen s := isOpen_Ioo
  have f_contOn : ContinuousOn (fun (x : ‚Ñù) => f (x + z.im * I)) s := hf.re_aux_1 hz
  have int1 : IntervalIntegrable (fun (x : ‚Ñù) => f (x + z.im * I)) MeasureTheory.volume z.re z.re
  ¬∑ apply ContinuousOn.intervalIntegrable
    apply f_contOn.mono
    simp [mem_ball.mp hz]
  have int2 : StronglyMeasurableAtFilter (fun (x : ‚Ñù) => f (x + z.im * I)) (ùìù z.re) :=
    ContinuousOn.stronglyMeasurableAtFilter s_open f_contOn _ zRe_mem_s
  have int3 : ContinuousAt (fun (x : ‚Ñù) => f (x + z.im * I)) z.re :=
    s_open.continuousOn_iff.mp f_contOn zRe_mem_s
--%% This is just the fundamental theorem of calculus.
  have := @intervalIntegral.integral_hasDerivAt_right (f := fun (x : ‚Ñù) ‚Ü¶ f (x + z.im * I))
    (a := z.re) (b := z.re) _ _ _ int1 int2 int3
  dsimp [HasDerivAt, HasDerivAtFilter, HasFDerivAtFilter] at this
  simp only [intervalIntegral.integral_same, sub_zero, re_add_im, map_sub] at this
  convert this using 3
  ring_nf
  congr
--%% \end{proof}

/-%%
Therefore as the complex variable $w \to z$, the horizontal integral of $f$ from $z$ to
$\Re(w)+i\Im(z)$ is equal to $(\Re(w - z)) f(z)$, up to $o(w - z)$.
\begin{lemma}
  \label{deriv_of_wedgeInt_re}
  \lean{deriv_of_wedgeInt_re}\leanok
  As $w \to z$,
  $$
    \int_{\Re(z)}^{\Re(w)} f(t + i\Im(z))\ dt
    =
    \Re(w-z) f(z)
    +
    o(w-z)
    .
  $$
\end{lemma}
%%-/
/- The horizontal integral of `f` from `z` to `z.re + w.im * I` is equal to `(w - z).re * f z`
  up to `o(w - z)`, as `w` tends to `z`. -/
theorem deriv_of_wedgeInt_re {c : ‚ÑÇ} {r : ‚Ñù} {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : ContinuousOn f (ball c r))
  {z : ‚ÑÇ} (hz : z ‚àà ball c r) :
  (fun (w : ‚ÑÇ) ‚Ü¶ (‚à´ x in z.re..w.re, f (x + z.im * I)) - ((w - z).re) * f z)
    =o[ùìù z] (fun w ‚Ü¶ w - z) := by
--%% \begin{proof}
  have zReTendsTo : Filter.Tendsto (fun (w : ‚ÑÇ) ‚Ü¶ w.re) (ùìù z) (ùìù z.re) :=
    by apply Continuous.tendsto Complex.continuous_re
  have := (deriv_of_wedgeInt_re' hf hz).comp_tendsto zReTendsTo
  have := this.trans_isBigO re_isBigO
--%% Simply apply the previous lemma, together with the fact that $\Re(w - z) = O(w - z)$ as $w \to z$.
  convert this using 2
  congr
  simp
--%% \end{proof}


/-%%
For the vertical integral, we need not the integral of $f(\Re(z)+iy)$, but rather that of $f(\Re(w)+iy)$.
The latter is close to $f(z)$ as $w \to z$; here is an auxiliary lemma.
\begin{lemma}
  \label{deriv_of_wedgeInt_im'}
  \lean{deriv_of_wedgeInt_im'}\leanok
  As $w \to z$,
  $$
    \int_{\Im(z)}^{\Im(w)} (f(\Re(w)+iy) - f (z))\ dy
    =
    o(w-z)
    .
  $$
\end{lemma}
%%-/
theorem deriv_of_wedgeInt_im' {c : ‚ÑÇ} {r : ‚Ñù} {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : ContinuousOn f (ball c r))
  {z : ‚ÑÇ} (hz : z ‚àà ball c r) :
  (fun w ‚Ü¶ ‚à´ y in z.im..w.im, f (w.re + y * I) - f z)
    =o[ùìù z] fun w ‚Ü¶ w - z := by
--%% \begin{proof}
--%% Use the fact that the map $w \mapsto f(w)-f(z)$ is $o(1)$ as $w \to z$.
  have : (fun w ‚Ü¶ f w - f z) =o[ùìù z] fun (_ : ‚ÑÇ) ‚Ü¶ (1 : ‚ÑÇ)
  ¬∑ refine (Asymptotics.continuousAt_iff_isLittleO (f := f) (x := z)).mp ((hf z hz).continuousAt ?_)
    exact (IsOpen.mem_nhds_iff isOpen_ball).mpr hz
  rw [Asymptotics.IsLittleO] at this ‚ä¢
  intro Œµ Œµ_pos
  have := this Œµ_pos
  simp only [Asymptotics.isBigOWith_iff, Pi.one_apply, norm_one, mul_one ] at this ‚ä¢
  have : ‚àÄ·∂† (w : ‚ÑÇ) in ùìù z, ‚àÄ y ‚àà Œô z.im w.im, ‚Äñf (w.re + y * I) - f z‚Äñ ‚â§ Œµ
  ¬∑ rw [Metric.nhds_basis_closedBall.eventually_iff] at this ‚ä¢
    obtain ‚ü®i, i_pos, hi‚ü© := this
    refine ‚ü®i, i_pos, fun w w_in_ball y y_in_I ‚Ü¶ hi (mem_closedBall_aux w_in_ball y_in_I)‚ü©
  apply this.mono ?_
  exact fun w hw ‚Ü¶ calc
    _ ‚â§ Œµ * |w.im - z.im|  := intervalIntegral.norm_integral_le_of_norm_le_const hw
    _ = Œµ * |(w - z).im| := by simp
    _ ‚â§ Œµ  * ‚Äñw - z‚Äñ := by gcongr; apply abs_im_le_abs
--%% \end{proof}

/-%%
Then as the complex variable $w \to z$, the vertical integral of $f$ from $\Re(w)+i\Im(z)$ to
$w$ is equal to $(\Im(w - z)) f(z)$, up to $o(w - z)$.
\begin{lemma}
  \label{deriv_of_wedgeInt_im}
  \lean{deriv_of_wedgeInt_im}\leanok
  As $w \to z$,
  $$
    \int_{\Im(z)}^{\Im(w)} f(\Re(w) + i y)\ dy
    =
    \Im(w-z) f(z)
    +
    o(w-z)
    .
  $$
\end{lemma}
%%-/
/--   The vertical integral of `f` from `w.re + z.im * I` to `w` is equal to `(w - z).im * f z`
  up to `o(w - z)`, as `w` tends to `z`. -/
theorem deriv_of_wedgeInt_im {c : ‚ÑÇ} {r : ‚Ñù} {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : ContinuousOn f (ball c r))
  {z : ‚ÑÇ} (hz : z ‚àà ball c r) :
  (fun w ‚Ü¶ (‚à´ y in z.im..w.im, f (w.re + y * I)) - (w - z).im * f z)
    =o[ùìù z] fun w ‚Ü¶ w - z := by
--%% \begin{proof}
--%% Convert $\Im(w-z) f(z)$ to $(\Im(w-z)) f(z) - \int_{\Im(z)}^{\Im(w)} f(\Re(w) + i y)\ dy$,
--%% and apply the previous lemma.
  calc
    _ = (fun w:‚ÑÇ ‚Ü¶ (‚à´ y in z.im..w.im, f (w.re + y * I)) - (‚à´ _ in z.im..w.im, f z)) := by congr! 2; simp
    _ = (fun w ‚Ü¶ ‚à´ y in z.im..w.im, f (w.re + y * I) - f z) := ?_
    _ =o[ùìù z] fun w => w - z := deriv_of_wedgeInt_im' hf hz
  ext1 w
  rw [intervalIntegral.integral_sub ?_ continuousOn_const.intervalIntegrable]
  exact (hf.im_aux_1 hz w).intervalIntegrable
--%% \end{proof}

/-%%
Putting everything together, we obtain the derivative of the wedge integral.
\begin{theorem}
  \label{deriv_of_wedgeInt}
  \lean{deriv_of_wedgeInt}\leanok
  As $w \to z$,
  $$
    \frac{d}{dw} \int_{z\to_W\  w} f(x)\ dx
    =
    f(z)
    .
  $$
  \end{theorem}
%%-/
/-- The `WedgeInt` has derivative at `z` equal to `f z`. -/
theorem deriv_of_wedgeInt {c : ‚ÑÇ} {r : ‚Ñù} {f : ‚ÑÇ ‚Üí ‚ÑÇ}
    (f_cont : ContinuousOn f (ball c r)) (hf : VanishesOnRectanglesInDisc c r f)
    {z : ‚ÑÇ} (hz : z ‚àà ball c r) :
    HasDerivAt (fun w => WedgeInt c w f) (f z) z := by
--%% \begin{proof}
  have : 0 < r := pos_of_mem_ball hz
  dsimp [HasDerivAt, HasDerivAtFilter, HasFDerivAtFilter]
--%% Break the wedge integral into two parts, and apply the previous two lemmas.
  calc
    _ =·∂†[ùìù z] (fun w ‚Ü¶ WedgeInt z w f - (w - z) * f z) := ?_
    _ = (fun w ‚Ü¶ (‚à´ x in z.re..w.re, f (‚Üëx + ‚Üëz.im * I)) - (w - z).re * f z)
        + I ‚Ä¢ (fun w ‚Ü¶ (‚à´ y in z.im..w.im, f (w.re + y * I)) - (w - z).im * f z) := ?_
    _ =o[ùìù z] fun w ‚Ü¶ w - z :=
      (deriv_of_wedgeInt_re f_cont hz).add ((deriv_of_wedgeInt_im f_cont hz).const_smul_left I)
  ¬∑ filter_upwards [VanishesOnRectanglesInDisc.diff_of_wedges hz f_cont hf]
    exact fun a ha ‚Ü¶ by rw [ha]
  ext1 w
  simp only [WedgeInt, smul_eq_mul, sub_re, ofReal_sub, sub_im, Pi.add_apply, Pi.smul_apply]
  set intI := ‚à´ (x : ‚Ñù) in z.re..w.re, f (x + z.im * I)
  set intII := ‚à´ (y : ‚Ñù) in z.im..w.im, f (w.re + y * I)
  calc
    _ = intI + I * intII - ((w - z).re + (w - z).im * I) * f z := by congr; rw [re_add_im]
    _ = intI + I * intII - ((w.re - z.re) + (w.im - z.im) * I) * f z := by simp
    _ = intI - (w.re - z.re) * f z + I * (intII - (w.im - z.im) * f z) := by ring
--%% \end{proof}

/-%%
This is Moreira's theorem.
\begin {theorem}[Moreira's theorem]
\label {moreira}
\lean {moreira}\leanok
Let $f$ be a continuous function on a disc $D(c,r)$, and suppose that $f$ vanishes on rectangles in $D(c,r)$. Then $f$ has a primitive on $D(c,r)$.
\end {theorem}
%%-/
/-- ** Moreira's theorem ** A function `f` which is continuous on a disc and whose integral on rectangles
  in the disc vanishes has a primitive on the disc. -/
theorem moreiras_theorem {c : ‚ÑÇ} {r : ‚Ñù} {f : ‚ÑÇ ‚Üí ‚ÑÇ}
    (hf : ContinuousOn f (ball c r))
    (hf‚ÇÇ : VanishesOnRectanglesInDisc c r f) :
    ‚àÉ g : ‚ÑÇ ‚Üí ‚ÑÇ, ‚àÄ z ‚àà (ball c r), HasDerivAt g (f z) z :=
  ‚ü®fun z ‚Ü¶ WedgeInt c z f, fun _ hz ‚Ü¶ deriv_of_wedgeInt hf hf‚ÇÇ hz‚ü©
--%% \begin{proof} The wedge integral has derivative $f(z)$ at $z$, by the previous lemma. \end{proof}

/-%%
If $f$ is not just continuous but holomorphic, then the integral of $f$ over any rectangle is zero.
\begin{lemma}
  \label{vanishesOnRectangles_of_holomorphic}
  \lean{vanishesOnRectangles_of_holomorphic}\leanok
  If $f$ is holomorphic on a set $U$, then the rectangle integral of $f$ vanishes, for any rectangle in $U$.
\end{lemma}
%%-/
/-- If `f` is `DifferentiableOn` a set `U`, then the rectangle integral of `f` vanishes, for any
  rectangle in `U`. -/
theorem vanishesOnRectangles_of_holomorphic {f : ‚ÑÇ ‚Üí ‚ÑÇ} {U : Set ‚ÑÇ} {z w : ‚ÑÇ}
    (hf : DifferentiableOn ‚ÑÇ f U)
    (hU : Rectangle z w ‚äÜ U) :
    RectangleIntegral f z w = 0 := by
--%% \begin{proof}
--%% Apply Green's theorem to the rectangle.
  convert integral_boundary_rect_eq_zero_of_differentiable_on_off_countable f z w ‚àÖ (by simp)
    ((hf.mono hU).continuousOn) ?_ using 1
  intro x hx
  apply hf.differentiableAt
  rw [_root_.mem_nhds_iff]
  refine ‚ü®Ioo (min z.re w.re) (max z.re w.re) √ó‚ÑÇ Ioo (min z.im w.im) (max z.im w.im), ?_, ?_, ?_‚ü©
  ¬∑ apply subset_trans ?_ hU
    rw [Rectangle]
    apply reProdIm_subset_iff'.mpr
    left
    constructor <;> convert uIoo_subset_uIcc _ _ using 1
  ¬∑ exact IsOpen.reProdIm isOpen_Ioo isOpen_Ioo
  ¬∑ convert hx using 1; simp
--%% \end{proof}

/-%%
\begin{lemma}
  \label{vanishesOnRectanglesInDisc_of_holomorphic}
  \lean{vanishesOnRectanglesInDisc_of_holomorphic}\leanok
  If $f$ is holomorphic on a disc $D(c,r)$, then $f$ vanishes on rectangles in $D(c,r)$.
\end{lemma}
%%-/
/-- If `f` is `DifferentiableOn` a disc, then `f` vanishes on rectangles in the disc. -/
theorem vanishesOnRectanglesInDisc_of_holomorphic {c : ‚ÑÇ} {r : ‚Ñù} {f : ‚ÑÇ ‚Üí ‚ÑÇ}
    (hf : DifferentiableOn ‚ÑÇ f (ball c r)) :
    VanishesOnRectanglesInDisc c r f := fun _ _ hz hw hz' hw' ‚Ü¶
  vanishesOnRectangles_of_holomorphic hf (rectangle_in_convex (convex_ball c r) hz hw hz' hw')
--%% \begin{proof} Apply the previous lemma. \end{proof}

/-%%
We finally prove our main theorem, the holomorphic functions on a disc have primitives.
\begin{theorem}[Primitive of holomorphic functions]
  \label{hasPrimitives_of_disc}
  \lean{hasPrimitives_of_disc}\leanok
  If $f$ is holomorphic on a disc $D(c,r)$, then $f$ has a primitive on $D(c,r)$.
\end{theorem}
%%-/
/-- ** Primitive of holomorphic functions on discs ** A holomorphic function on a disc has
  primitives. -/
theorem hasPrimitives_of_disc (c : ‚ÑÇ) {r : ‚Ñù} : HasPrimitives (ball c r) :=
  fun _ hf ‚Ü¶ moreiras_theorem hf.continuousOn (vanishesOnRectanglesInDisc_of_holomorphic hf)
--%% \begin{proof} Apply Moreira's theorem and the previous lemma. \end{proof}

end Complex
